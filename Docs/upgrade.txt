[model: OpenAI o3]
Дата/время: 4 января 2026, 13:49 (Europe/Kyiv)

Да, получится — причём заметно. Сейчас ваш стек уже рабочий, а улучшать его лучше в трёх направлениях: (1) гарантировать “без потери видео”, (2) поднять качество/естественность русской дорожки, (3) сделать пайплайн быстрее, устойчивее и проще в сопровождении.

<details> <summary><b>1) Самое простое улучшение: “видео всегда без ухудшения”</b></summary>

Если при финальном мультиплексировании вы делаете -c:v copy, то видеопоток вообще не перекодируется → качество видео строго идентичное исходнику. Тогда сравнение качества видео не нужно — достаточно проверки, что видео реально копируется.

Что сделать:

Ввести правило: “любой финальный выход” по умолчанию копирует видео (-map 0:v:0 -c:v copy)

Делать QC-проверку ffprobe: codec, width/height, fps, duration, frame count, bit_rate — должны совпасть (или отличаться только контейнерными мелочами).

Рекомендация по контейнеру:

Для хранения “1 файл, 2 дорожки (Original + RU dub)” лучше MKV (обычно надежнее с несколькими дорожками, метаданными, языками, тайтлами). MP4 тоже можно, но иногда капризнее у плееров.

Пример команды (идея):
ffmpeg -y -i input.mkv -i ru_full.wav \
  -map 0:v:0 -map 0:a:0 -map 1:a:0 \
  -c:v copy -c:a aac -b:a 192k \
  -metadata:s:a:0 language=eng -metadata:s:a:0 title="Original" \
  -metadata:s:a:1 language=rus -metadata:s:a:1 title="Russian Dub" \
  output.mkv

  И “пруф” QC
  :ffprobe -hide_banner -show_streams -select_streams v:0 input.mkv
ffprobe -hide_banner -show_streams -select_streams v:0 output.mkv



Если видеопараметры и кодек совпали — видео не трогалось.

</details> <details> <summary><b>2) Качество русской дорожки: “как в продакшене”</b></summary>

Типовые проблемы TTS-дубляжа: громкость скачет, слышны стыки сегментов, нет “воздуха”, темп/интонация неестественные.

Аудио-постпроцесс, который реально поднимает “ощущение качества”:

Loudness normalization до целевого уровня (например, -16 LUFS для online / -23 LUFS для broadcast — зависит от цели).

Limiter (чтобы убрать клиппинг) + контроль True Peak.

Лёгкий noise gate / room tone (или подложка “тишины комнаты”) чтобы паузы не были “мертвыми”.

Кроссфейды на стыках сегментов (5–30 мс) + маленькие fade-in/out.

Приведение частоты дискретизации к видео-проекту (часто 48 kHz).


Супер-практичный минимум прямо в ffmpeg:

EBU R128 loudnorm (2-pass) + limiter (через alimiter) + легкие фейды (если у вас уже один ru_full.wav).

И отдельная проверка клиппинга (astats) / True Peak.

Ещё один сильный апгрейд:
Сегменты сейчас вы “подгоняете по длительности”. Лучше делать это так, чтобы не убивать тембр:

time-stretch с сохранением формантов (где возможно),

и ограничивать stretch (например ±8–12%), а остальное добирать паузами, а не растяжкой.

</details> <details> <summary><b>3) Скорость и устойчивость пайплайна</b></summary>

3.1. Кэш и чекпойнты (must-have)

Каждый шаг пишет артефакт + “stamp” (хэш входов/настроек).

Если stamp совпал — шаг пропускается.

Это ускоряет итерации в разы и спасает от “перезапусти всё заново”.

3.2. Раздельный CPU/GPU по шагам
Вы уже мыслите правильно (“пока общая галочка, но будет раздельно”). Самый практичный вариант:

device_map в конфиге: asr: cuda, align: cuda, diar: cuda, translate: cpu, tts: cuda, mux: cpu.

Плюс лимиты: max VRAM / batch size per step.





3.3. Параллелизм “без боли”

Перевод сегментов батчами (не по одному) — почти бесплатный прирост.

Генерацию TTS сегментов можно распараллелить по CPU (если модель позволяет) или очередью на GPU с “подкачкой” (осторожно с VRAM).

I/O: меньше промежуточных wav/json там, где можно, но без фанатизма (простота важнее).

3.4. Режим восстановления

Если упало на шаге N — при рестарте продолжает с N, не трогая 1..N-1.

</details> <details> <summary><b>4) Архитектурно: сделать DubPipeline “плагинным” и проще для UI</b></summary>

С учётом ваших планов (единый dubpipeline.pipeline, потом UI) — лучшее:

Command + Template Method для шагов (у вас это уже обсуждалось).

Единый контракт шага: inputs(), outputs(), run(), qc()

QC-отчёт (JSON) на каждый шаг: длительности, кол-во сегментов, покрытие, предупреждения.

Конфиг — строго типизированный (dataclass/pydantic) + валидация путей/placeholder-ов.

И тогда UI (даже простой) будет просто “выбор пресета + запуск пайплайна + просмотр QC”.

</details>



Если хотите, я бы улучшал стек в таком порядке (самый быстрый эффект)

Гарантия “video passthrough” + QC ffprobe (и лучше MKV для 2 дорожек).

Аудио-постпроцесс RU: loudness/limiter + кроссфейды + 48k.

Кэш/чекпойнты + device_map по шагам.

Если покажете ваш текущий pipeline.yaml (или кусок про шаги/параметры устройств/выходные файлы) — я сразу предложу конкретную структуру device_map, “stamps”, и формат QC-отчёта под ваш код.